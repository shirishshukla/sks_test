---

##
# Description:
##

## Variables
variables:
  K8S_DIR: "${CI_PROJECT_DIR}/k8s"
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  APP_NAME: BulkWeather
  EKSCLUSTER: Dev_Eks_Cluster
  KUBECONFIG: /etc/k8sconfig
  REGION: us-west-1
  DEPL_TMPLFILE: deployment.tmpl.yml
  DEPLFILE: deployment.yaml
  #CONTAINER_REPO: bulkweather
  #CONTAINER_REGISTRY: "xxxxxxx.dkr.ecr.us-west-1.amazonaws.com"


# Environment specific variable setup
.set_env: &set_env
  environment:
    name: deployment
  variables:
    env_tag: test
    namespace: dep-test


# Common Task properties
.common_config: &common_config
  only:
    - main   # only to run for this branch
  rules:
    - if: $CI_COMMIT_BRANCH == "main"


.docker_login: &docker_login |
    echo Docker Login To AWS ECR
    docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY


.build_image: &build_image |
    echo "Building container image $IMAGE_TAG"
    cd ${CI_PROJECT_DIR}
    docker build -t $IMAGE_TAG .
    docker push $IMAGE_TAG


# setup kubectl and k8s auth
.set_kubeconfig: &set_kubeconfig |
    echo Do awscli install
    curl -L0 "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
    unzip awscliv2.zip
    ./aws/install
    aws --version
    rm -rf awscliv2.zip
    echo Do kubectl binary
    curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
    chmod +x kubectl
    mv kubectl /usr/local/bin/
    echo setting k8s config...
    echo * setup eks cluster auth *
    aws sts get-caller-identity
    aws eks update-kubeconfig --name $EKSCLUSTER --region $REGION --kubeconfig $KUBECONFIG
    echo xxxxxxxxxxxxxxxx
    cat -n $KUBECONFIG
    echo xxxxxxxxxxxxxxxx
    kubectl config view
    kubectl version
    # create secrets
    kubectl create secret docker-registry gitlab-registry-auth --docker-server=$CI_REGISTRY --docker-username=$CI_REGISTRY_USER --docker-password=$CI_REGISTRY_PASSWORD || true


# create deployment file
.create_depfile: &create_depfile |
    echo xxxx Creating deployment file xxxx
    cd ${K8S_DIR}
    cp $DEPL_TMPLFILE $DEPLFILE
    sed -i "s|{{NAMESPACE}}|${namespace}|g" $DEPLFILE
    sed -i "s|{{APP_NAME}}|${APP_NAME}|g" $DEPLFILE
    sed -i "s|{{CONTAINER_IMAGE}}|${IMAGE_TAG}|g" k8s/deployment.yaml
    echo xx done xx


# set namespace to current context
.set_namespace: &set_namespace |
    echo Setting default namespace to $namespace
    kubectl config set-context --current --namespace=$namespace
    echo done


## xxxx Stages xxxx ##
.initialize: &initialize
  stage: initialize
  <<: *set_env
  <<: *common_config
  script:
    - *set_kubeconfig


.validate: &validate
  stage: validate
  <<: *set_env
  <<: *common_config
  script:
    - *set_kubeconfig
    - *create_depfile
    - cd ${K8S_DIR}
    - kubectl get namespaces && echo kubectl auth working ... || (echo "FAIL - kubectl auth failed." && exit 1)
    - kubectl get namespaces $namespace || (echo namespace $namespace not exist && exit 1)
    - echo Below deployment to be created ...
    - echo xxxxxxxxxxxxxxxx deployment file xxxxxxxxxxxxxxxx
    - cat -n $DEPLFILE
    - echo xxxxxxxxxxxxxxxx END xxxxxxxxxxxxxxxx
    - echo Validate deployment file $DEPLFILE ...
    - kubectl apply -f $DEPLFILE --dry-run=client -n $namespace


# build image
.build: &build
  stage: build
  <<: *set_env
  <<: *common_config
  script:
    - *set_kubeconfig
    - *docker_login
    - *build_image


# create namespace and apply manifest
.deploy: &deploy
  stage: deploy
  <<: *set_env
  <<: *common_config
  script:
    - *set_kubeconfig
    - *create_depfile
    - echo create namespace if not exist ...
    - kubectl get namespaces
    - kubectl describe namespace $namespace || kubectl create namespace $namespace
    - *set_namespace
    - cd ${K8S_DIR}
    - kubectl apply -f $DEPLFILE


# test
.test: &test
  stage: test
  <<: *set_env
  <<: *common_config
  script:
    - *set_kubeconfig
    - *set_namespace
    - cd ${K8S_DIR}
    - echo Validating pod
    - kubectl get pods | grep ${APP_NAME}
    #- kubectl get service ${APP_NAME}
    #- |
    #    for cnt in {1..10}; do
    #      echo RETRY: $cnts
    #      LBURL=$(kubectl get svc ${APP_NAME} | awk '/LoadBalancer/ {print $4}')
    #      [ ! -z $LBURL ] && break
    #      sleep 6
    #    done
    #    echo Load Balancer URL : http://$LBURL
    #    [ ! -z $LBURL ] && curl -L $LBURL && echo SUCCESS || (echo FAILED TO GET LB IP && exit 1)


# destroy
.destroy: &destroy
  stage: cleanup
  <<: *set_env
  <<: *common_config
  when: manual
  script:
    - *set_kubeconfig
    - *create_depfile
    - *set_namespace
    - cd ${K8S_DIR}
    - echo Deleting deployment cleanup ...
    - kubectl delete -f $DEPLFILE
    - echo Cleanup is successfull ..

## END
